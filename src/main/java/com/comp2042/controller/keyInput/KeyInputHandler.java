package com.comp2042.controller.keyInput;

import com.comp2042.events.EventSource;
import com.comp2042.events.EventType;
import com.comp2042.events.InputEventListener;
import com.comp2042.events.MoveEvent;
import com.comp2042.view.data.ViewData;
import javafx.scene.input.KeyEvent;

import javafx.event.ActionEvent;
import java.util.function.Consumer;

/**
 * Handles all keyboard input for the game.
 * Separates the brick control actions (movement, rotate, slam, hold),
 * and global
 *
 *
 * <p>It delegates brick control events to the game logic via {@code InputEventListener}
 * and global actions to dedicated consumers.
 * This supports the Single Responsibility Principle (SRP) by externalizing input handling
 *.</p>
 */
public class KeyInputHandler {

    private final InputEventListener eventListener;

    private final Consumer<ActionEvent> newGameAction;
    private final Consumer<ActionEvent> pauseGameAction;

    /**
     * Constructs a new KeyInputHandler.
     *
     * @param eventListener The listener responsible for processing brick movement/control events.
     * @param newGameAction A consumer to execute the new game logic.
     * @param pauseGameAction A consumer to execute the pause/resume logic.
     */
    public KeyInputHandler(
            InputEventListener eventListener,
            Consumer<ActionEvent> newGameAction,
            Consumer<ActionEvent> pauseGameAction
    ) {
        this.eventListener = eventListener;
        this.newGameAction = newGameAction;
        this.pauseGameAction = pauseGameAction;
    }

    /**
     * Handles key inputs for global game state changes.
     * <ul>
     * <li>**N**: New Game</li>
     * <li>**ESCAPE**: Pause/Resume Game</li>
     * </ul>
     *
     * @param keyEvent The KeyEvent generated by the user's key press.
     */
    public void handleGlobalKeys(KeyEvent keyEvent) {
        switch (keyEvent.getCode()) {
            case N -> newGameAction.accept(null);
            case ESCAPE -> pauseGameAction.accept(null);
        }
    }

    /**
     * Handles key inputs for controlling the falling brick and delegating to the core game logic.
     *
     * <ul>
     * <li>**LEFT/A**: Move Left</li>
     * <li>**RIGHT/D**: Move Right</li>
     * <li>**UP/W**: Rotate</li>
     * <li>**DOWN/S**: Soft Drop (delegated to {@code moveDownHandler})</li>
     * <li>**SPACE**: Hard Drop (delegated to {@code hardDropHandler})</li>
     * <li>**C**: Hold Brick</li>
     * </ul>
     *
     * @param keyEvent The KeyEvent generated by the user's key press.
     * @param moveDownHandler A consumer for handling the soft drop (DOWN/S) event, which involves move-down game logic.
     * @param refreshHandler A consumer to refresh the brick display after simple movements (Left, Right, Rotate, Hold).
     * @param hardDropHandler A consumer for handling the instant drop (SPACE) event.
     */
    public void handleBrickControlKeys(KeyEvent keyEvent, Consumer<MoveEvent> moveDownHandler, Consumer<ViewData> refreshHandler,
                                       Consumer<MoveEvent> hardDropHandler) {

        switch (keyEvent.getCode()) {
            case LEFT, A ->
                    refreshHandler.accept(
                            eventListener.onLeftEvent(new MoveEvent(EventType.LEFT, EventSource.USER))
                    );
            case RIGHT, D ->
                    refreshHandler.accept(
                            eventListener.onRightEvent(new MoveEvent(EventType.RIGHT, EventSource.USER))
                    );
            case UP, W ->
                    refreshHandler.accept(
                            eventListener.onRotateEvent(new MoveEvent(EventType.ROTATE, EventSource.USER))
                    );
            case DOWN, S ->
                    moveDownHandler.accept(
                            new MoveEvent(EventType.DOWN, EventSource.USER)
                    );
            case SPACE -> hardDropHandler.accept(new MoveEvent(EventType.SLAM, EventSource.USER));
            case C ->
                    refreshHandler.accept(
                            eventListener.onHoldEvent(new MoveEvent(EventType.HOLD, EventSource.USER))
                    );
        }
    }
}
